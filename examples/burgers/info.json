{
  "problem": {
    "name": "pde_burgers",
    "description": "The PDE is the burgers equation, given by\n\n\\\\[\\n\\\\begin{{cases}}\\n\\\\partial_t u(x, t) + \\\\partial_x \\left( \\\\frac{{u^2(x, t)}}{{2}} \\right) = \\\\nu \\\\partial_{{xx}} u(x, t), & x \\\\in (0,1), \\; t \\\\in (0,1] \\\\\\\\u(x, 0) = u_0(x), & x \\\\in (0,1)\\n\\\\end{{cases}}\\n\\\\]\\n\\nwheer $\\\\nu$ is a constant representing the viscosity. In our task, we assume the periodic boundary condition.\\n\\nGiven the discretization of $u_0(x)$ of shape [batch_size, N] where $N$ is the number of spatial points, you need to implement a solver to predict u(\\\\cdot, t) for the specified subseqent time steps ($t=t_1, ..., t_T$). The solution is of shape [batch_size, T+1, N] (with the initial time frame and the subsequent steps). Note that although the required time steps are specified, you should consider using smaller time steps internally to obtain more stable simulation.\\n\\nIn particular, your code should be tailored to the case where $\\\\nu={burgers_nu}$, i.e., optimizing it particularly for this use case.",
    "metric": "nRMSE, convergence rate, and time: For executable solvers, we evaluate their performance by calling the solver, obtaining the predicted solution, and comparing it against reference solutions. We investigate three metrics. First, we compute the error with respect to the ground truth solution. We use the scale-independent normalized root mean squared error (nRMSE), defined as: nRMSE = \\frac{1}{S} \\sum_{s=1}^{S} \\frac{\\lVert u^{(s)}(x,t) - \\hat{u}^{(s)}(x,t)\\rVert_{2}}{\\lVert u^{(s)}(x,t)\\rVert_{2}} (2) where S denotes the number of examples in a PDE family. Second, we measure the quality of the solver using a convergence test, which assesses how the solution error decreases as the grid is refined. This test verifies that the numerical solution approaches the reference or exact solution at an expected rate, confirming the solver’s consistency and correctness. Mathematically, a solver is considered convergent if the difference between solutions at successive resolutions decreases with finer discretization. That is, for a grid spacing h, we test whether \\lVert u_{h} - u_{h/2}\\rVert_{2} → 0 as h → 0. This test makes sure that the numerical solution remains stable and consistent as resolution increases, even in the absence of an exact solution. Finally, we record code execution time as a measure of computational efficiency.",
    "interface": "deepevolve_interface.py"
  },
  "initial_idea": {
    "title": "The initial idea",
    "content": "The solver integrates the one-dimensional viscous Burgers equation $u_t + \\tfrac{1}{2}(u^2)_x = \\nu\\,u_{xx}$ on a periodic domain with an explicit Euler time integrator written in PyTorch. For each batch of $B$ initial states sampled on an evenly spaced grid of $N$ points ($\\Delta x = 1/N$), the code first computes the convective flux $f=\\tfrac{1}{2}u^{2}$, evaluates its spatial derivative with a centered finite-difference stencil implemented through `torch.roll`, and obtains the diffusion term $u_{xx}$ with the standard three-point Laplacian. The time step for the inner loop is chosen adaptively but never exceeds $0.2\\,\\Delta x^{2}/\\nu$, satisfying the explicit stability criterion for the diffusive term. Integration proceeds on the GPU when available, updating the solution tensor in place until the simulation time matches each requested output time in the user-supplied array $\\{t_0,\\dots,t_T\\}$. At every such moment the current field is stored, producing an output tensor of shape $[B,\\,T+1,\\,N]$ that contains the initial conditions and all subsequent states in single precision before conversion back to NumPy.",
    "supplement": "https://github.com/LithiumDA/CodePDE/blob/main/solvers/burgers/nu_1.0/seeds/implementation_0.py"
  }
}